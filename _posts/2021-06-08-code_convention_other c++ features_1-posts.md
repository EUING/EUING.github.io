---
layout: post
title: Google C++ Style Guide 6-1
subtitle: Other C++ Features 부분 정리.
tags: [C++, guide]
---

-------------

# Other C++ Features
## Rvalue References
- 장점
    - 이동 생성자를 정의하면 가르키는 포인터 값만 교체하는 방식으로 복사보다 성능이 향상 될 수 있음.
    - 오른값 참조를 사용하면 이동 가능하지만 복사할 수 없는 형식을 구현할 수 있음.
    - 복사에 대한 개념이 애매한 객체에 대해서도 함수 인수 및 컨테이너로 전달할 수 있음.
- 단점
    - 오른값 참조는 아직 보편적이지 않으며 보편 참조 혹은 참조 축약 개념은 아직 모호함.
- 결론
    - && 한정자 및 오른값 참조는 아래의 상황 이외에는 사용하지 말 것.
	    1. 이동 생성자 혹은 이동 배정을 정의할 때.
		2. `std::forward`와 함께 완벽한 전달을 구현할 때.
		3. 값으로 전달 하는 것보다 `Foo&&, const Foo&`를 오버로딩하는 것이 확실한 성능 상승이 있을 경우.
		4. && 한정자로 함수를 정의하여 임시 객체에 대해 `*this`를 사용할 수 없게 할 때.
		5. 일반 함수에 매개 변수는 값으로 전달하는 것이 좋음.
		
## Friends
- 합당한 이유가 있으면 friend class와 함수를 허용.
- friend는 보통 같은 파일에 정의되므로 private 멤버 변수를 찾아서 사용할 때 다른 파일을 찾을 필요가 없음.
- 대표적으로 Foo 클래스에 대해 factory 클래스를 구현하거나 단위 테스트 클래스에 사용함.
- friend는 클래스의 캡슐화 경계를 확장하지만 깨지는 않음.
- 다른 클래스에 대해 private 멤버 변수에 대한 권한을 부여할 때 public으로 선언하는 것보다 friend가 나을 수 있음.

## Exceptions
- 장점
    - 예외는 다른 현대 언어에서 사용되므로 C++에서도 사용하면 일관성이 있음.
	- 일부 다른 C++ 라이브러리에서 예외를 사용하므로 해당 라이브러리와 통합하기 쉬워짐.
	- 생성자의 실패를 알릴 수 있는 유일한 방법임.
	- 프레임 워크를 테스트 할 때 편리함.
- 단점
    - 만약 f()가 g()를 호출하고 g()가 h()를 호출하는 상황에서 h()의 throw을 f()에서 catch 할 경우,
      g()가 확실하게 정리 안 될 수 있으므로 throw를 추가하려면 모든 호출을 조사해야 함.
    - 일반적으로 예외는 코드를 보고 프로그램의 흐름을 따라가기 어렵고 함수는 예상하지 못한 위치에서 반환 될 수 있음.
	- 예외를 설정하면 컴파일 시간 및 목적 코드가 증가하고 사용 가능한 주소 공간이 작아질 수 있음.
- 결론
    - 겉으로 보기에는 예외를 사용할 경우 신규 프로젝트의 비용보다 크지만 기존 코드의 경우 예외를 도입하면 모든 종속적인 코드에 영향을 미침.
	- 구글의 기존 C++ 코드는 대부분 예외를 처리할 준비가 안되어 있기 때문에 예외를 발생시키는 새로운 코드를 채택하기 어려움.

## noexcept
- noexcept는 함수가 예외 발생 여부를 지정하는 데 사용하고 만약 noexcept가 지정된 함수에서 예외가 방출되면 `std::termindate`에 의해 프로그램이 종료됨.
- 장점
    - noexcept로 선언된 생성자를 컨테이너에 전달 할 경우 이동 연산으로 인해 성능이 향상 될 수 있음.
	- noexcept를 선언하면 컴파일러가 최적화 할 수 있음.
- 단점
    - noexcept 지정자를 정확하게 쓰고 있는 지 확인하기 어려움.
    - noexcept 지정자를 한번 사용하면 나중에 취소하기 어려움.	
- 결론
    - 함수의 의도된 의미를 정확하게 반영하는 경우에만 사용할 것.
	- 이동 생성자를 제외하고는 의미 있는 성능 이점이 없다고 가정할 수 있음.
	- 예외를 사용하지 않는 프로젝트에서는 선호.
	
## Run-Time Type Information (RTTI)
- 장점
    - RTTI에 대한 대안책은 클래스의 설계를 바꾸는 것이지만 널리 사용되고 있는 코드에서는 수정하기 어려움.
	- 새로 생성된 객체가 예상되는 유형을 가지고 있는지 테스트해야하는 factory 클래스에서는 유용함.
- 단점
    - 런타임에 객체 유형을 자주 확인하는 것은 설계 문제를 의미함.
	- 무분별하게 RTTI를 사용하면 코드를 유지하기 어려워짐.
- 결론
    - 단위 테스트에서는 자유롭게 사용해도 되지만, 다른 코드에서는 가능하면 사용하지 말 것.
	- 객체의 클래스마다 다르게 동작하는 코드를 작성하고 싶으면 다음 대안 중 하나를 선택
	    1. 가상 함수를 선언하여 런타임중에 동적으로 함수를 호출 할 것.
		2. 객체의 동작이 클래스 외부에 속하면 방문자 패턴 같은 double-dispatch 솔루션을 적용할 것.
		
## Casting
- 장점
    - 중괄호 초기화 혹은 C++ 스타일 캐스팅은 C 스타일 캐스팅은 작업의 모호함을 줄일 수 있음.
- 단점
    - C++ 스타일 캐스팅은 구문이 복잡함.
- 결론
    - C 스타일 캐스팅은 지양하고 C++ 스타일 캐스팅을 사용할 것.
	    1. 중괄호 초기화를 사용하여 산술 유형을 변환할 때 정보가 손실 될 수 있는 경우 컴파일 되지 않기 때문에 안전함. e.g.) `int64_t{x}`
		2. 명시적으로 up/down-cast를 사용할 때 static_cast를 사용할 것.
		3. const 한정자를 제거할 때 const_cast를 사용할 것.
		
## Streams
- 구현 세부 정보가 아닌 사용자가 볼 수 있는 값에 대해서만 `<<`를 오버로딩 하고, 사람이 읽을 수 있는 문자열 표현을 사용할 것.
- 디버깅을 위해 객체 내부를 출력하는 경우 오버로딩 보다는 함수를 정의 할 것. e.g.) `DebugString()`

## Preincrement and Predecrement
- 장점
    - 후위 증감식은 코드를 해석하는 데 어렵고 복사본을 만들기 때문에 효율적이지 않음
- 단점
    - 전통적으로 반복문을 사용할 때 후위 증감식을 사용했음.
- 결론
    - 후위 증감식이 명시적으로 필요하지 않으면 전위 증감식을 사용할 것.

## Use of const
- 장점
    - 변수가 사용되는 방식을 쉽게 이해할 수 있고 컴파일러가 더 나은 코드를 생성 할 수 있도록 함.
	- 변수를 수정하지 못한다는 것을 알 수 있기 때문에 프로그램의 신뢰성이 높음.
	- 멀티 스레드 프로그램에서 안전하게 사용할 수 있음.
- 단점
    - const 객체를 함수로 전달하기 위해서는 const 인자를 가지는 함수가 있어야 함.
- 결론
    - API에서 const를 강력하게 추천.
	- 값으로 전달되는 함수의 경우 cosnt는 호출자에게 영향을 주지 않으므로 권장하지 않음.
	- 객체의 상태를 변경하거나 참조를 반환하는 것이 아니라면 const를 선언할 것.
    - 지역변수에 대한 const는 상황에 맞게 사용할 것.
	- const를 먼저 붙이는 것을 추천하지만 주변 코드의 일관성을 확인 할 것. e.g.) `const int* foo, int const* foo`
	
## Use of constexpr
- 컴파일 시간의 상수를 정의하거나 상수 초기화를 보장할 때 사용.
- constexpr를 사용하면 리터널이 아닌 경우에도 컴파일 시간의 상수로 사용할 수 있음.
- 인라인을 강제하기 위해 constexpr를 사용하지 말 것.

## Integer Types
- 정수형 타입을 사용할 경우 int만 사용할 것.
- 만약 크기가 다른 정수형을 사용할 경우 `<stdint.h>`에 있는 정수형 타입을 사용할 것. e.g.) `int16_t`
- int보다 크지 않은 값을 사용하더라도 계산하는 과정에서 overflow가 발생할 수 있음.
- int 타입이 64bit 환경이더라도 8byte로 가정하지 말 것.
- 숫자가 아닌 bit를 나타내거나 2<sup>n</sup>의 최댓값을 나타내는 것이 아니면 unsigned를 사용하지 말 것.

## 64-bit Portability
- 64bit 및 32bit을 호환해야 하므로 비교, 구조체 정렬, 출력 등을 확인 할 것.
- 포인터 크기의 정수를 사용하려면 intptr_t를 사용할 것.

## Preprocessor Macros
- 헤더 및 C++ API에서 매크로를 정의 하지 말고 인라인 함수, enum, const 변수를 선호 할 것.
- 매크로로 긴 변수 이름을 축약하는 대신 참조를 사용할 것.
- 코드를 조건부로 컴파일 하기 위해 매크로를 사용하지 말 것.

## 0 및 nullptr / NULL
- 포인터는 nullptr을 사용하고 char은 '\0'을 사용 할 것.
- C++03 프로젝트에서는 0보다 NULL을 선호 할 것. 단, 0을 나타내기 위해 NULL을 사용하지 말 것.

## sizeof
- sizeof(type) 보다 sizeof(varname)을 선호 할 것.
- sizeof(varname)을 사용할 경우 해당 변수의 자료형을 변경하면 적절하게 갱신 됨.
- 특정 변수와 관계없는 코드에서는 sizeof(type)을 사용할 수 있음.
~~~C
    MyStruct data;
	memset(&data, 0, sizeof(data)); // Good
	memset(&data, 0, sizeof(MyStruct)); // Bad
	
	if (raw_size < sizeof(int)) { // OK
	    return false;
	}
~~~